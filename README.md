# CS300-final-project
- What was the problem you were solving in the projects for this course?
In these projects I solved two key problems. The first was analyzing the runtime and memory efficiency of different data structures for storing and managing courses in a Computer Science curriculum. The second involved designing and implementing a binary search tree (BST) to solve the requirements I was analyzing solutions for in the first project.

- How did you approach the problem? Consider why data structures are important to understand.
For Project One I compared the performance characteristics of vectors, hash tables, and binary search trees. I evaluated their advantages and disadvantages in terms of time complexity for operations such as insertion, lookup, and retrieval in sorted order. For Project Two I implemented a binary search tree because it inherently maintains sorted order, allowing efficient alphanumeric listing and search operations. Understanding data structures is vital, as they influence the scalability and efficiency of software solutions.

- How did you overcome any roadblocks you encountered while going through the activities or project?
One challenge was validating course prerequisites and ensuring the tree maintained consistency when data was malformed or incomplete. I resolved this by having the validation function treat the entire import similar to a transaction, in that it would clear the tree if there were any failures. 

- How has your work on this project expanded your approach to designing software and developing programs?
This project emphasized the importance of selecting the right data structure for the specific problem. I tend to use a List ADS for everything, and I will be putting more consideration into what data structure should be used to implement functionality in the future.

- How has your work on this project evolved the way you write programs that are maintainable, readable, and adaptable?
I focused on writing self-documenting code with descriptive variable and function names, alongside inline comments to explain complex logic. This resulted in a maintainable, readable, and adaptable implementation. Additionally, a modular approach makes it easier to extend or modify the codebase as requirements change.
